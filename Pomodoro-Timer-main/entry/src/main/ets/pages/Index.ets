import { promptAction, router } from '@kit.ArkUI';
import dataPreferences from '@ohos.data.preferences';
import { TimerCard } from '../components/TimerCard';
import { TaskItem } from '../components/TaskItem';
import { HttpService } from '../common/HttpService';

interface Task {
  id: number;
  title: string;
  completed: boolean;
  pomodoros: number;
  todayPomodoros: number;
  lastPomodoroDate: string;
}

interface FocusHistoryRecord {
  seconds: number;
  taskIds: number[];
}

// Ê∑ªÂä†‰∏ªÈ¢òÈ¢úËâ≤Êé•Âè£
interface ThemeColors {
  primary: string;
  secondary: string;
  background: string;
  cardBg: string;
  textPrimary: string;
  textSecondary: string;
}

@Entry
@Component
struct Index {
  @State remainingTime: number = 25 * 60;
  @State isRunning: boolean = false;
  @State isWorkTime: boolean = true;
  @State tasks: Task[] = [];
  @State newTask: string = '';
  @State currentTaskId: number = -1;
  @State totalPomodoros: number = 0;
  @State todayPomodoros: number = 0;
  @State showAddTask: boolean = false;
  @State todayDate: string = new Date().toDateString();
  @State refreshFlag: number = 0;
  private focusHistory: Record<string, FocusHistoryRecord> = {};
  private currentSessionSeconds: number = 0;
  private timer: number = 0;
  private preferences: dataPreferences.Preferences | null = null;
  // Ê∑ªÂä† dialogController
  dialogController: CustomDialogController = new CustomDialogController({
    builder: this.DialogBuilder,
    alignment: DialogAlignment.Center,
    offset: { dx: 0, dy: -20 },
    customStyle: true,
    autoCancel: true,
    cancel: () => {
      this.showAddTask = false;
    }
  });
  // Ê∑ªÂä†Âà†Èô§ÂØπËØùÊ°ÜÊéßÂà∂Âô®
  deleteDialogController: CustomDialogController = new CustomDialogController({
    builder: this.DeleteDialogBuilder,
    alignment: DialogAlignment.Center,
    offset: { dx: 0, dy: -20 },
    customStyle: true,
    autoCancel: true
  });
  // ÂΩìÂâçË¶ÅÂà†Èô§ÁöÑ‰ªªÂä°ID
  @State taskToDelete: Task | null = null;

  // ÂÆö‰πâÂØπËØùÊ°ÜÂÜÖÂÆπÊûÑÂª∫Âô®
  @Builder
  DialogBuilder() {
    Column() {
      Text('Ê∑ªÂä†‰ªªÂä°')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .margin({ top: 16, bottom: 16 })

      TextInput({ placeholder: 'ËæìÂÖ•‰ªªÂä°ÂêçÁß∞' })
        .width('90%')
        .height(50)
        .margin({ top: 8 })
        .onChange((value: string) => {
          this.newTask = value;
        })

      Row() {
        Button('ÂèñÊ∂à')
          .width('40%')
          .height(40)
          .backgroundColor(this.themeColors.textSecondary)
          .margin({ top: 20, right: 8 })
          .onClick(() => {
            this.dialogController.close();
            this.showAddTask = false;
          })

        Button('Ê∑ªÂä†')
          .width('40%')
          .height(40)
          .backgroundColor(this.themeColors.primary)
          .margin({ top: 20, left: 8 })
          .onClick(() => {
            if (this.newTask.trim()) {
              // Ê£ÄÊü•‰ªªÂä°ÂêçÁß∞ÊòØÂê¶ÈáçÂ§ç
              if (this.isTaskNameDuplicate(this.newTask.trim())) {
                promptAction.showToast({
                  message: '‰ªªÂä°ÂêçÁß∞Â∑≤Â≠òÂú®',
                  duration: 2000,
                });
                return;
              }
              this.createTask(this.newTask);
              this.newTask = '';
              this.dialogController.close();
              this.showAddTask = false;
            }
          })
      }
      .width('90%')
      .justifyContent(FlexAlign.SpaceAround)
    }
    .width('90%')
    .padding(16)
    .backgroundColor(Color.White)
    .borderRadius(24)
  }

  // ÂÆö‰πâÂà†Èô§Á°ÆËÆ§ÂØπËØùÊ°ÜÂÜÖÂÆπ
  @Builder
  DeleteDialogBuilder() {
    Column() {
      Text('Á°ÆËÆ§Âà†Èô§')
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .margin({ top: 16, bottom: 16 })

      Text(this.taskToDelete ? `ÊòØÂê¶Âà†Èô§‰ªªÂä°"${this.taskToDelete.title}"Ôºü` : '')
        .fontSize(16)
        .fontColor(this.themeColors.textSecondary)
        .margin({ bottom: 20 })
        .textAlign(TextAlign.Center)

      Row() {
        Button('ÂèñÊ∂à')
          .width('40%')
          .height(40)
          .backgroundColor(this.themeColors.textSecondary)
          .margin({ top: 20, right: 8 })
          .onClick(() => {
            this.deleteDialogController.close();
            this.taskToDelete = null;
          })

        Button('Âà†Èô§')
          .width('40%')
          .height(40)
          .backgroundColor(this.themeColors.primary)
          .margin({ top: 20, left: 8 })
          .onClick(() => {
            if (this.taskToDelete) {
              this.deleteTask(this.taskToDelete);
            }
            this.deleteDialogController.close();
            this.taskToDelete = null;
          })
      }
      .width('90%')
      .justifyContent(FlexAlign.SpaceAround)
    }
    .width('90%')
    .padding(16)
    .backgroundColor(Color.White)
    .borderRadius(24)
  }

  // Ê∑ªÂä†Ê£ÄÊü•‰ªªÂä°ÂêçÁß∞ÊòØÂê¶ÈáçÂ§çÁöÑÊñπÊ≥ï
  private isTaskNameDuplicate(taskName: string): boolean {
    return this.tasks.some(task => task.title.toLowerCase() === taskName.toLowerCase());
  }

  async aboutToAppear() {
    try {
      // Ëé∑ÂèñpreferencesÂÆû‰æã
      const context = getContext(this);
      this.preferences = await dataPreferences.getPreferences(context, 'PomodoroData');

      // Âä†ËΩΩ‰øùÂ≠òÁöÑÊï∞ÊçÆ
      const tasksStr = await this.preferences.get('tasks', '[]');
      this.tasks = JSON.parse(tasksStr as string);
      this.totalPomodoros = await this.preferences.get('totalPomodoros', 0) as number;
      const focusHistoryStr = await this.preferences.get('focusHistory', '{}');
      this.focusHistory = JSON.parse(focusHistoryStr as string);

      // ÂàùÂßãÂåñ‰ªäÊó•ÊÄªÁï™ËåÑÊï∞
      this.updateTodayTotal();
    } catch (error) {
      console.error('Failed to load data:', error);
    }
  }

  // Ê∑ªÂä†‰øùÂ≠òÊï∞ÊçÆÁöÑÊñπÊ≥ï
  private async saveData() {
    if (this.preferences) {
      try {
        await this.preferences.put('tasks', JSON.stringify(this.tasks));
        await this.preferences.put('totalPomodoros', this.totalPomodoros);
        await this.preferences.flush();
      } catch (error) {
        console.error('Failed to save data:', error);
      }
    }
  }

  // ‰øÆÊîπ‰∏ªÈ¢òÈ¢úËâ≤ÂÆö‰πâÔºåÊ∑ªÂä†Á±ªÂûãÂ£∞Êòé
  readonly themeColors: ThemeColors = {
    primary: '#FF6B6B', // Áï™ËåÑÁ∫¢
    secondary: '#4ECDC4', // Ê∏ÖÊñ∞Èùí
    background: '#F7F7F7', // ÊµÖÁÅ∞ËÉåÊôØ
    cardBg: '#FFFFFF', // Âç°ÁâáËÉåÊôØ
    textPrimary: '#2D3436', // ‰∏ªË¶ÅÊñáÂ≠ó
    textSecondary: '#636E72'// Ê¨°Ë¶ÅÊñáÂ≠ó
  }

  @Builder
  TimerSection() {
    TimerCard({
      remainingTime: this.remainingTime,
      isRunning: this.isRunning,
      isWorkTime: this.isWorkTime,
      primaryColor: this.themeColors.primary,
      secondaryColor: this.themeColors.secondary,
      cardBg: this.themeColors.cardBg,
      textSecondary: this.themeColors.textSecondary,
      onStartClick: (): void => {
        this.toggleTimer();
      },
      onResetClick: (): void => {
        this.resetTimer();
      }
    })
  }

  @Builder
  TaskSection() {
    Column() {
      Row() {
        Text('‰ªªÂä°ÂàóË°®')
          .fontSize(20)
          .fontWeight(FontWeight.Medium)
          .fontColor(this.themeColors.textPrimary)

        Blank()

        Button('+')
          .width(50)
          .height(40)
          .fontSize(24)
          .fontWeight(FontWeight.Medium)
          .backgroundColor(this.themeColors.primary)
          .borderRadius(20)
          .onClick(() => {
            this.showAddTask = true;
            this.dialogController.open();
          })
      }
      .width('100%')
      .padding({
        left: 16,
        right: 16,
        top: 16,
        bottom: 8
      })

      List() {
        ForEach(this.tasks, (task: Task) => {
          ListItem() {
            TaskItem({
              task: task,
              isActive: this.currentTaskId === task.id,
              primaryColor: this.themeColors.primary,
              cardBg: this.themeColors.cardBg,
              textPrimary: this.themeColors.textPrimary,
              textSecondary: this.themeColors.textSecondary,
              onTaskClick: (): void => {
                this.selectTask(task.id);
              },
              onDeleteClick: (): void => {
                this.showDeleteConfirm(task);
              }
            })
            .gesture(
              LongPressGesture()
                .onAction(() => {
                  this.showDeleteConfirm(task);
                })
            )
          }
          .margin({ bottom: 5 })
          .swipeAction({ end: this.DeleteButton(task) })
        })
      }
      .width('100%')
      .height('30%')
      .padding({ left: 16, right: 16 })
      .scrollBar(BarState.Auto)

      Row() {
        Text(`‰ªäÊó•ÂÆåÊàêÔºö${this.todayPomodoros} üçÖ`)
          .fontSize(16)
          .fontWeight(FontWeight.Medium)
          .fontColor(this.themeColors.primary)

        Blank()

        Text(`ÊÄªËÆ°ÂÆåÊàêÔºö${this.totalPomodoros} üçÖ`)
          .fontSize(20)
          .fontWeight(FontWeight.Medium)
          .fontColor(this.themeColors.textSecondary)
      }
      .width('100%')
      .padding({
        left: 16,
        right: 16,
        top: 12,
        bottom: 12
      })
      .backgroundColor(this.themeColors.cardBg)
      .borderRadius(16)
      .margin({ top: 16 })
    }
  }

  // Ê∑ªÂä†Âà†Èô§ÊåâÈíÆÊûÑÂª∫Âô®
  @Builder
  DeleteButton(task: Task) {
    Button() {
      Text('Âà†Èô§')
        .fontSize(16)
        .fontColor(Color.White)
    }
    .width(80)
    .height('100%')
    .backgroundColor(Color.Red)
    .onClick(() => {
      this.showDeleteConfirm(task);
    })
  }

  // ‰øÆÊîπÊòæÁ§∫Âà†Èô§Á°ÆËÆ§ÊñπÊ≥ï
  private showDeleteConfirm(task: Task) {
    this.taskToDelete = task;
    this.deleteDialogController.open();
  }

  // Ê∑ªÂä†Âà†Èô§‰ªªÂä°ÊñπÊ≥ï
  private async deleteTask(delTask: Task) {
    // Â¶ÇÊûúÂà†Èô§ÁöÑÊòØÂΩìÂâçÈÄâ‰∏≠ÁöÑ‰ªªÂä°ÔºåÊ∏ÖÈô§ÈÄâ‰∏≠Áä∂ÊÄÅ
    if (delTask.id === this.currentTaskId) {
      this.currentTaskId = -1;
    }

    // ÂàõÂª∫Êñ∞ÁöÑ‰ªªÂä°Êï∞ÁªÑÔºåÊéíÈô§Ë¶ÅÂà†Èô§ÁöÑ‰ªªÂä°
    const newTasks: Task[] = [];
    for (const task of this.tasks) {
      if (task.id !== delTask.id) {
        newTasks.push(task);
      }
    }

    // Êõ¥Êñ∞‰ªªÂä°ÂàóË°®
    this.tasks = newTasks;

    // Êõ¥Êñ∞‰ªäÊó•ÊÄªÁï™ËåÑÊï∞
    this.updateTodayTotal();

    // ‰øùÂ≠òÊõ¥Êîπ
    await this.saveData();

    // ÊòæÁ§∫Âà†Èô§ÊàêÂäüÊèêÁ§∫
    promptAction.showToast({
      message: '‰ªªÂä° ' + delTask.title + ' Â∑≤Âà†Èô§',
      duration: 2000,
    });
  }

  build() {
    Column() {
      // È°∂ÈÉ®ÂØºËà™Ê†è
      Row() {
        Text('Áï™ËåÑÊó∂Èíü')
          .fontSize(22)
          .fontWeight(FontWeight.Bold)
          .fontColor(this.themeColors.textPrimary)
        
        Blank()
        
        // ÂØºËà™ÊåâÈíÆ
        Row() {
          Button('ÁªüËÆ°')
            .width(60)
            .height(36)
            .fontSize(14)
            .backgroundColor(this.themeColors.secondary)
            .borderRadius(18)
            .margin({ right: 8 })
            .onClick(() => {
              router.pushUrl({
                url: 'pages/Statistics'
              });
            })
          
          Button('ËÆæÁΩÆ')
            .width(60)
            .height(36)
            .fontSize(14)
            .backgroundColor(this.themeColors.textSecondary)
            .borderRadius(18)
            .onClick(() => {
              router.pushUrl({
                url: 'pages/Settings'
              });
            })
        }
      }
      .width('100%')
      .height(56)
      .padding({ left: 16, right: 16 })
      .backgroundColor(this.themeColors.cardBg)
      .borderRadius(16)
      .margin({ bottom: 16 })
      
      Scroll() {
        Column() {
          this.TimerSection()
          this.TaskSection()
        }
        .width('100%')
      }
      .layoutWeight(1)
      .scrollBar(BarState.Auto)
    }
    .width('100%')
    .height('100%')
    .backgroundColor(this.themeColors.background)
    .padding(16)
  }

  private formatTime(seconds: number): string {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
  }

  private toggleTimer() {
    if (this.isRunning) {
      clearInterval(this.timer);
      void this.commitFocusTime();
    } else {
      this.currentSessionSeconds = 0;
      this.timer = setInterval(async () => {
        if (this.remainingTime > 0) {
          this.remainingTime--;
          if (this.isWorkTime) {
            this.currentSessionSeconds++;
          }
        } else {
          await this.completePomodoro();
        }
      }, 1000);
    }
    this.isRunning = !this.isRunning;
  }

  private resetTimer() {
    clearInterval(this.timer);
    void this.commitFocusTime();
    this.isRunning = false;
    this.currentSessionSeconds = 0;
    this.remainingTime = this.isWorkTime ? 25 * 60 : 5 * 60;
  }

  private async completePomodoro() {
    if (this.isWorkTime) {
      await this.commitFocusTime();
      this.totalPomodoros++;

      if (this.currentTaskId !== -1) {
        const taskIndex = this.tasks.findIndex(t => t.id === this.currentTaskId);
        if (taskIndex !== -1) {
          // ÂàõÂª∫Êñ∞ÁöÑ‰ªªÂä°Êï∞ÁªÑÂπ∂Êõ¥Êñ∞‰ªªÂä°
          const newTasks: Task[] = [];
          for (let i = 0; i < this.tasks.length; i++) {
            if (i === taskIndex) {
              const today = new Date().toDateString();
              newTasks.push({
                id: this.tasks[i].id,
                title: this.tasks[i].title,
                completed: this.tasks[i].completed,
                pomodoros: this.tasks[i].pomodoros + 1,
                todayPomodoros: this.tasks[i].lastPomodoroDate === today ?
                  this.tasks[i].todayPomodoros + 1 : 1,
                lastPomodoroDate: today
              });
            } else {
              newTasks.push(this.tasks[i]);
            }
          }

          // Êõ¥Êñ∞‰ªªÂä°Êï∞ÁªÑ
          this.tasks = newTasks;

          // Á´ãÂç≥Êõ¥Êñ∞‰ªäÊó•ÊÄªÁï™ËåÑÊï∞
          this.updateTodayTotal();
        }
      }

      await this.saveData();

      promptAction.showToast({
        message: 'Â§™Ê£í‰∫ÜÔºÅÂÆåÊàê‰∫Ü‰∏Ä‰∏™üçÖÔºÅ',
        duration: 2000,
      });
    }
    this.switchMode();
  }

  // Êõ¥Êñ∞‰ªäÊó•ÊÄªÁï™ËåÑÊï∞
  private updateTodayTotal() {
    const today = new Date().toDateString();
    let total = 0;
    for (const task of this.tasks) {
      if (task.lastPomodoroDate === today) {
        total += task.todayPomodoros;
      }
    }
    this.todayPomodoros = total;
  }

  private async commitFocusTime() {
    if (this.currentSessionSeconds <= 0 || !this.preferences) {
      this.currentSessionSeconds = 0;
      return;
    }
    let latestHistory: Record<string, FocusHistoryRecord> = {};
    try {
      const focusHistoryStr = await this.preferences.get('focusHistory', '{}');
      latestHistory = JSON.parse(focusHistoryStr as string);
    } catch (error) {
      console.error('Failed to reload focus history:', error);
      latestHistory = {};
    }

    const today = new Date().toDateString();
    if (!latestHistory[today]) {
      latestHistory[today] = {
        seconds: 0,
        taskIds: []
      };
    }
    latestHistory[today].seconds += this.currentSessionSeconds;
    if (this.currentTaskId !== -1 && latestHistory[today].taskIds.indexOf(this.currentTaskId) === -1) {
      latestHistory[today].taskIds.push(this.currentTaskId);
    }

    try {
      await this.preferences.put('focusHistory', JSON.stringify(latestHistory));
      await this.preferences.flush();
      this.focusHistory = latestHistory;
    } catch (error) {
      console.error('Failed to save focus history:', error);
    } finally {
      this.currentSessionSeconds = 0;
    }
  }

  private switchMode() {
    this.isWorkTime = !this.isWorkTime;
    this.remainingTime = this.isWorkTime ? 25 * 60 : 5 * 60;
    this.resetTimer();
  }

  private selectTask(id: number) {
    this.currentTaskId = id;
  }

  private async createTask(title: string) {
    const newTask: Task = {
      id: Date.now(),
      title: title,
      completed: false,
      pomodoros: 0,
      todayPomodoros: 0,
      lastPomodoroDate: new Date().toDateString()
    };

    // ÂàõÂª∫Êñ∞Êï∞ÁªÑÂπ∂Ê∑ªÂä†‰ªªÂä°
    const newTasks: Task[] = [];
    for (const task of this.tasks) {
      newTasks.push(task);
    }
    newTasks.push(newTask);

    this.tasks = newTasks;
    await this.saveData();
  }

  aboutToDisappear() {
    clearInterval(this.timer);
    void this.commitFocusTime();
    if (this.preferences) {
      this.preferences.flush();
    }
  }
}